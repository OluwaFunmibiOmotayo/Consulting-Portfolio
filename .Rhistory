##Writing a function to use the formula from textbook(5.2)
loocv = function(fit){
h = lm.influence(fit)$h
mean((residual(fit)/(1-h))^2)
}
##Trying it out
loocv(glm.fit)
lm.influence(glm.fit)$h
##Writing a function to use the formula from textbook(5.2)
loocv = function(fit){
h = lm.influence(fit)$h
mean((residuals(fit)/(1-h))^2)
}
##Trying it out
loocv(glm.fit)
cv.error = rep(0,5)
degree = 1:5
for(d in degree){
glm.fit = glm(mpg~poly(horsepower,d), data = Auto)
cv.error[d] = loocv(glm.fit)
}
plot(degree, cv.error, type = "b")
## 10-fold CV
cv.error10 = rep(0,5)
for(d in degree){
glm.fit = glm(mpg~poly(horsepower,d), data = Auto)
cv.error[d] = cv.glm(Auto,glm.fit, K = 10)$delta[1]
}
lines(degree,cv.error10,type="b", col ="red")
cv.error = rep(0,5)
degree = 1:5
for(d in degree){
glm.fit = glm(mpg~poly(horsepower,d), data = Auto)
cv.error[d] = loocv(glm.fit)
}
plot(degree, cv.error, type = "b")
## 10-fold CV
cv.error10 = rep(0,5)
for(d in degree){
glm.fit = glm(mpg~poly(horsepower,d), data = Auto)
cv.error[d] = cv.glm(Auto,glm.fit, K = 10)$delta[1]
}
lines(degree,cv.error10,type="b", col ="red")
cv.error = rep(0,5)
degree = 1:5
for(d in degree){
glm.fit = glm(mpg~poly(horsepower,d), data = Auto)
cv.error[d] = loocv(glm.fit)
}
plot(degree, cv.error, type = "b")
## 10-fold CV
cv.error10 = rep(0,5)
for(d in degree){
glm.fit = glm(mpg~poly(horsepower,d), data = Auto)
cv.error10[d] = cv.glm(Auto,glm.fit, K = 10)$delta[1]
}
lines(degree,cv.error10,type="b", col ="red")
alpha = function(x,y){
vx = var(x)
vy=var(y)
cxy=cov(x,y)
(vy-cxy)/(vx+vy-2*cxy)
}
alpha(Portfolio$X,Portfolio$Y)
alpha.fn = function(data,index){
with(data[index,],aplha(X,Y))
}
alpha.fn(Portfolio, 1:100)
alpha.fn = function(data,index){
with(data[index,],alpha(X,Y))
}
alpha.fn(Portfolio, 1:100)
set.seed(1)
alpha.fn(Portfolio, sample(1:100,100, replace=TRUE))
boot.out =boot(Portfolio, alpha.fn, R = 1000)
boot.out
plot(boot.out)
#Generate a simulated data
set.seed(1)
x = rnorm(100)
y = x-2 *x^2 +rnorm(100)
str(y)
y = x - (2*x^2) +rnorm(100)
#Generate a simulated data
set.seed(1)
x = rnorm(100)
y = x - (2*x^2) +rnorm(100)
plot(x,y)
?plot
dat <- data.frame(x = x, y = y)
degree = 1:4
for(d in degree){
glm.fit = glm(y~poly(x,d), data = dat)
cv.error[d] = loocv(glm.fit)
}
plot(degree, cv.error, type = "b")
cv.error = rep(0,4)
degree = 1:4
for(d in degree){
glm.fit = glm(y~poly(x,d), data = dat)
cv.error[d] = loocv(glm.fit)
}
plot(degree, cv.error, type = "b")
cv.error
set.seed(18)
cv.error = rep(0,4)
degree = 1:4
for(d in degree){
glm.fit = glm(y~poly(x,d), data = dat)
cv.error[d] = loocv(glm.fit)
}
cv.error
plot(degree, cv.error, type = "b")
set.seed(98)
cv.error = rep(0,4)
degree = 1:4
for(d in degree){
glm.fit = glm(y~poly(x,d), data = dat)
cv.error[d] = loocv(glm.fit)
}
cv.error
plot(degree, cv.error, type = "b")
plot(x,y)
glm.fit1 = glm(y~poly(x,1), data = dat)
summary(glm.fit1)
glm.fit2 = glm(y~poly(x,2), data = dat)
summary(glm.fit2)
glm.fit3 = glm(y~poly(x,3), data = dat)
summary(glm.fit3)
glm.fit4 = glm(y~poly(x,4), data = dat)
summary(glm.fit4)
require(boston)
glimpse(boston)
glimpse(Boston)
glimpse(Boston)
require(ISLR)
glimpse(Boston)
?Boston
require(MASS)
glimpse(Boston)
require(ISLR2)
glimpse(Boston)
se <- sd(Boston$medv)/sqrt(length(Boston$medv))
se
se.fn = function(data,index){
mean(vector[index])
}
set.seed(1)
boot.out =boot(Boston$medv, se.fn, R = 1000)
se.fn = function(data,index){
mean(vector[index])
}
set.seed(1)
se.fn(Boston$medv, sample(1:100,100, replace=TRUE))
se.fn = function(data,index){
mean(data[index,"medv"])
}
boot.out =boot(Boston$medv, se.fn, R = 1000)
bootstrap.func = function(data, index){
return(mean(data[index, "medv"]))
}
boot(Boston$medv, bootstrap.func, 9999)
alpha = function(x,y){
vx = var(x)
vy=var(y)
cxy=cov(x,y)
(vy-cxy)/(vx+vy-2*cxy)
}
alpha(Portfolio$X,Portfolio$Y)
alpha.fn = function(data,index){
with(data[index,],alpha(X,Y))
}
alpha.fn(Portfolio, 1:100)
set.seed(1)
alpha.fn(Portfolio, sample(1:100,100, replace=TRUE))
boot.out =boot(Portfolio, alpha.fn, R = 1000)
boot.out
se.fn = function(data,index){
mean(data[index,"medv"])
}
alpha(X,Y)
se.fn = function(data,index){
mean(data[index,"medv"])
}
boot.out =boot(Portfolio, se.fn, R = 1000)
boot.out
se.fn = function(data,index){
mean(data[index])
}
boot.out =boot(Portfolio, se.fn, R = 1000)
# Define the function to compute the mean
boot_fn <- function(data, index) {
return(mean(data[index]))
}
# Perform bootstrap
set.seed(42)  # For reproducibility
boot_result <- boot(Boston$medv, boot_fn, R = 1000)
# Print results
boot_result
# Define the function to compute the mean
boot_fn <- function(data, index) {
mean(data[index])
}
# Perform bootstrap
set.seed(42)  # For reproducibility
boot_result <- boot(Boston$medv, boot_fn, R = 1000)
# Print results
boot_result
boot_fn <- function(data, index) {
mean(data[index])
}
set.seed(42)  # For reproducibility
boot_result <- boot(Boston$medv, boot_fn, R = 1000)
boot_result
mean(Boston$medv)
se <- sd(Boston$medv)/sqrt(length(Boston$medv))
se
mean(Boston$medv)
se <- sd(Boston$medv)/sqrt(length(Boston$medv))
se
boot_fn <- function(data, index) {
mean(data[index])
}
set.seed(81)  # For reproducibility
boot_result <- boot(Boston$medv, boot_fn, R = 1000)
boot_result
t.test(Boston$medv)
boot_result$statistic
boot_results$t
boot_result$t
sd(boot_result$t)
sd(boot_result$t0
)
boot_result$t0
boot_result$R
boot_result$data
boot_result$statistic()
boot_result$sim
boot_result$stype
boot_result$weights
round(c(mean(Boston$medv) - 2*boot_results_SE, mean(Boston$medv) + 2*boot_results_SE), 4)
boot_results_SE <- sd(boot_result$t)
round(c(mean(Boston$medv) - 2*boot_results_SE, mean(Boston$medv) + 2*boot_results_SE), 4)
median(Boston$medv)
boot_fn <- function(data, index) {
median(data[index])
}
set.seed(81)  # For reproducibility
boot_result <- boot(Boston$medv, boot_fn, R = 1000)
boot_result
quantile(Boston$medv, 0.1)
quantile(Boston$medv, 0.1)
boot_fn <- function(data, index) {
quantile(data[index],0.1)
}
set.seed(81)
boot_result <- boot(Boston$medv, boot_fn, R = 1000)
boot_result
library(readr)
library(dplyr)
library(car)
library(lme4)
#Data Import
Fungicide_Data <- read_csv("Fungicide Exp 5 Design.csv")
View(Fungicide_Data)
str(Fungicide_Data)
Fungicide_Data$Avg_Measurement <- rowMeans(Fungicide_Data[,c("Measurement 1","Measurement 2", "Measurement 3","Measurement 4")], na.rm = TRUE)
summary(Fungicide_Data$Avg_Measurement)
# Remove the four measurement columns
Fungicide_Data <- Fungicide_Data[, !(names(Fungicide_Data) %in% c("Measurement 1", "Measurement 2", "Measurement 3", "Measurement 4","Comments","Dates"))]
str(Fungicide_Data)
# Rename variables
Fungicide_Data <- Fungicide_Data %>% rename(Dose = ...10)
#Converting to a Factor
Fungicide_Data <- Fungicide_Data %>%
mutate(
Species = as.factor(Species),
Isolates = as.factor(Isolates),
Treatments = as.factor(Treatments),
Dilution = as.factor(Dilution),
techRep = as.factor(techRep),
Exp_Code = as.factor(Exp_Code),
#Dose = as.factor(Dose)
)
# Check the structure of the dataset
str(Fungicide_Data)
summary(Fungicide_Data)
library(skimr)
skim(Fungicide_Data$Avg_Measurement)
percentage_zeros <- sum(Fungicide_Data$Avg_Measurement == 0, na.rm = TRUE) / nrow(Fungicide_Data) * 100
print(percentage_zeros)
####################################################################################################################################################
#log-transformed dose (added small constant to handle zeros)
Fungicide_Data$logDose <- log10(Fungicide_Data$Dose + 0.01)
lme_model1 <- lmer(Avg_Measurement~ Treatments * logDose +
(1|Species) +              # Random effect for species
(1|Species:Dose)+          # Random effect for doses nested with species
(1|Treatments:logDose),    # Random effect for doses nested within treatment
data = Fungicide_Data)
summary(lme_model1)
lme_model2 <- lmer(Avg_Measurement~ Treatments * logDose + I(logDose^2) +
(1|Species) +              # Random effect for species
(1|Species:Dose)+          # Random effect for doses nested with species
(1|Treatments:logDose),    # Random effect for doses nested within treatment
data = Fungicide_Data)
summary(lme_model2)
# ANOVA for fixed effects
anova(lme_model1)
anova(lme_model2)
car::Anova(lme_model1,type ="III")
car::Anova(lme_model2,type ="III")
# Random effects structure
print(VarCorr(lme_model), comp = "Variance")
#Likelihood Ratio Test
anova(lme_model1, lme_model2)
# Extract random effects
ranef(lme_model)
# Extract fixed effects
fixef(lme_model)
# Model diagnostics
par(mfrow = c(2,2))
# QQ plot
qqnorm(residuals(lme_model1))
qqline(residuals(lme_model1))
qqnorm(residuals(lme_model2))
qqline(residuals(lme_model2))
# Histogram of residuals
hist(residuals(lme_model1))
hist(residuals(lme_model2))
# Shapiro-Wilk test
shapiro.test(residuals(lme_model1))
shapiro.test(residuals(lme_model2))
install.packages("glmmTMB")
install.packages("glmmTMB")
library(glmmTMB)
zig_model <- glmmTMB(Avg_Measurement ~ Treatments * logDose +
(1|Species) + (1|Species:Dose) + (1|Treatments:logDose),
ziformula = ~ Treatments * logDose,  # Zero-inflation formula
family = ziGamma(link = "log"),
data = Fungicide_Data)
summary(zig_model)
zig_model <- glmmTMB(Avg_Measurement ~ Treatments * logDose +
(1|Species) + (1|Species:Dose) ,
ziformula = ~ Treatments * logDose,  # Zero-inflation formula
family = ziGamma(link = "log"),
data = Fungicide_Data)
ziln_model <- glmmTMB(Avg_Measurement ~ Treatments * logDose +
(1|Species) + (1|Species:Dose) + (1|Treatments:logDose),
ziformula = ~ Treatments * logDose,
family = gaussian(link = "log"),
data = Fungicide_Data)
zig_model <- glmmTMB(Avg_Measurement ~ Treatments * logDose +
(1|Species) + (1|Species:Dose) + (1|Treatments:logDose),
ziformula = ~ Treatments * logDose,
family = ziGamma(link = "log"),
data = Fungicide_Data)
# Two-part model: one for zeros and one for continuous values
zi_model <- glmmTMB(Avg_Measurement ~ Treatments * logDose +
(1|Species),
ziformula = ~Treatments * logDose,
family = gaussian,
data = Fungicide_Data)
# First model probability of being alive (non-zero)
binary_model <- glmer(I(Avg_Measurement > 0) ~ Treatments * logDose +
(1|Species),
family = binomial,
data = Fungicide_Data)
?glmer
library(lme4)
# First model probability of being alive (non-zero)
binary_model <- glmer(I(Avg_Measurement > 0) ~ Treatments * logDose +
(1|Species),
family = binomial,
data = Fungicide_Data)
# First model probability of being alive (non-zero)
binary_model <- glmer(I(Avg_Measurement > 0) ~ Treatments * logDose +
(1|Species)+              # Random effect for species
(1|Species:Dose)+          # Random effect for doses nested with species
(1|Treatments:logDose),
family = binomial,
data = Fungicide_Data)
summary(binary_model)
# Then model the non-zero measurements
continuous_model <- lmer(Avg_Measurement ~ Treatments * logDose +
(1|Species)+              # Random effect for species
(1|Species:Dose)+          # Random effect for doses nested with species
(1|Treatments:logDose),
data = subset(Fungicide_Data, Avg_Measurement > 0))
summary(continuous_model)
# Two-part model: one for zeros and one for continuous values
zi_model <- glmmTMB(Avg_Measurement ~ Treatments * logDose +
(1|Species)+              # Random effect for species
(1|Species:Dose)+          # Random effect for doses nested with species
(1|Treatments:logDose),
ziformula = ~Treatments * logDose,
family = gaussian,
data = Fungicide_Data)
# Two-part model: one for zeros and one for continuous values
zi_model <- glmmTMB(Avg_Measurement ~ Treatments * logDose +
(1|Species),
ziformula = ~Treatments * logDose,
family = gaussian,
control = glmmTMBControl(optimizer = "nlminb"),
data = Fungicide_Data)
zi_model <- glmmTMB(Avg_Measurement ~ Treatments * logDose +
(1|Species),
ziformula = ~Treatments + logDose,  # Removed interaction
family = gaussian,
data = Fungicide_Data)
zi_model <- glmmTMB(Avg_Measurement ~ Treatments * logDose +
(1|Species),
ziformula = ~Treatments * logDose,
family = gamma(link = "log"),  # Using gamma distribution
data = Fungicide_Data)
library(lme4)
# First model probability of being alive (non-zero)
binary_model <- glmer(I(Avg_Measurement > 0) ~ Treatments * logDose +
(1|Species)+              # Random effect for species
(1|Species:Dose)+          # Random effect for doses nested with species
(1|Treatments:logDose),
family = binomial,
data = Fungicide_Data)
summary(binary_model)
# Then model the non-zero measurements
continuous_model <- lmer(Avg_Measurement ~ Treatments * logDose +
(1|Species)+              # Random effect for species
(1|Species:Dose)+          # Random effect for doses nested with species
(1|Treatments:logDose),
data = subset(Fungicide_Data, Avg_Measurement > 0))
summary(continuous_model)
binary_model1 <- glmer(I(Avg_Measurement > 0) ~ Treatments * logDose +
(1|Species),
family = binomial,
data = Fungicide_Data)
binary_model2 <- glmer(I(Avg_Measurement > 0) ~ Treatments * logDose +
(1|Species) +
(1|Species:Dose),
family = binomial,
data = Fungicide_Data)
binary_model <- glmer(I(Avg_Measurement > 0) ~ Treatments * logDose +
(1|Species)+              # Random effect for species
(1|Species:Dose)+          # Random effect for doses nested with species
(1|Treatments:logDose),
family = binomial,
data = Fungicide_Data)
binary_model <- glmer(I(Avg_Measurement > 0) ~ Treatments * logDose +
(1|Species) + (1|Species:Dose),  # Remove (1|Treatments:logDose)
family = binomial,
data = Fungicide_Data,
control = glmerControl(optimizer = "bobyqa"))
# First model probability of being alive (non-zero)
binary_model <- glmer(I(Avg_Measurement > 0) ~ Treatments * logDose +
(1|Species)+              # Random effect for species
(1|Species:Dose)+          # Random effect for doses nested with species
(1|Treatments:logDose),
family = binomial,
data = Fungicide_Data)
binary_model_alt <- glmer(I(Avg_Measurement > 0) ~ Treatments * logDose +
(1|Species) + (1|Species:Dose) + (1|Treatments:logDose),
family = binomial, data = Fungicide_Data,
control = glmerControl(optimizer = "Nelder_Mead"))
# Check if any groups have complete separation
table(Fungicide_Data$Species, Fungicide_Data$Avg_Measurement > 0)
table(Fungicide_Data$Treatments, Fungicide_Data$Avg_Measurement > 0)
# Remove the species with complete separation
filtered_data <- subset(Fungicide_Data, Species != "Fusarium oxysporum")
simpler_model <- glmer(I(Avg_Measurement > 0) ~ Treatments * logDose + (1|Species),
family = binomial, data = filtered_data)
# First model probability of being alive (non-zero)
binary_model <- glmer(I(Avg_Measurement > 0) ~ Treatments * logDose +
(1|Species)+              # Random effect for species
(1|Species:Dose)+          # Random effect for doses nested with species
(1|Treatments:logDose),
family = binomial,
data = filtered_data)
# Then model the non-zero measurements
continuous_model <- lmer(Avg_Measurement ~ Treatments * logDose +
(1|Species)+              # Random effect for species
(1|Species:Dose)+          # Random effect for doses nested with species
(1|Treatments:logDose),
data = subset(Fungicide_Data, Avg_Measurement > 0))
summary(continuous_model)
AIC(continuous_model)
# QQ plot
qqnorm(residuals(continuous_model))
qqline(residuals(continuous_model))
library(glmmTMB)
# Check if any groups have complete separation
table(Fungicide_Data$Species, Fungicide_Data$Avg_Measurement > 0)
table(Fungicide_Data$Treatments, Fungicide_Data$Avg_Measurement > 0)
library(lme4)
# First model probability of being alive (non-zero)
binary_model <- glmer(I(Avg_Measurement > 0) ~ Treatments * logDose +
(1|Species)+              # Random effect for species
(1|Species:Dose)+          # Random effect for doses nested with species
(1|Treatments:logDose),
family = binomial,
data = Fungicide_Data)
#summary(binary_model)
library(glmmTMB)
binary_model_tmb <- glmmTMB(I(Avg_Measurement > 0) ~ Treatments * logDose +
(1|Species) +
(1|Species:Dose),
family = binomial,
data = Fungicide_Data)
library(brglm2)
install.packages("brglm2")
library(brglm2)
sep_check <- glm(I(Avg_Measurement > 0) ~ Treatments * logDose,
family = binomial,
data = Fungicide_Data)
summary(sep_check)
